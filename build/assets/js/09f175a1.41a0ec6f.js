"use strict";(globalThis.webpackChunkphysical_ai=globalThis.webpackChunkphysical_ai||[]).push([[579],{8453:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>a});var r=o(6540);const t={},i=r.createContext(t);function s(n){const e=r.useContext(i);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),r.createElement(i.Provider,{value:e},n.children)}},8533:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"robot-simulation-basics/lesson5","title":"Lesson 5: Bringing Robots to Life with ROS 2 Launch and Control","description":"In the exciting world of robotics, we need a way to orchestrate all the different components that make our robots move and think. This is where ROS 2 launch files and ros2_control come into play. They are like the conductor of an orchestra, ensuring every instrument plays its part perfectly.","source":"@site/docs/02-robot-simulation-basics/lesson5.md","sourceDirName":"02-robot-simulation-basics","slug":"/robot-simulation-basics/ros2-launch-and-control","permalink":"/physical-ai/docs/robot-simulation-basics/ros2-launch-and-control","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"sidebar_label":"Lesson 5: Bringing Robots to Life with ROS 2 Launch and Control","slug":"ros2-launch-and-control"},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 4: Diving into Gazebo","permalink":"/physical-ai/docs/robot-simulation-basics/diving-into-gazebo"},"next":{"title":"Lesson 6: Bringing Your Robot to Life with Sensors","permalink":"/physical-ai/docs/robot-simulation-basics/bringing-your-robot-to-life-with-sensors"}}');var t=o(4848),i=o(8453);const s={sidebar_position:5,sidebar_label:"Lesson 5: Bringing Robots to Life with ROS 2 Launch and Control",slug:"ros2-launch-and-control"},a="Lesson 5: Bringing Robots to Life with ROS 2 Launch and Control",l={},c=[{value:"The Magic of ROS 2 Launch Files",id:"the-magic-of-ros-2-launch-files",level:2},{value:"Spawning Your URDF Model in Gazebo",id:"spawning-your-urdf-model-in-gazebo",level:2},{value:"Configuring <code>ros2_control</code> for Your Robot",id:"configuring-ros2_control-for-your-robot",level:2},{value:"Sending Joint Commands with a ROS 2 Publisher",id:"sending-joint-commands-with-a-ros-2-publisher",level:2},{value:"Verifying Joint Commands",id:"verifying-joint-commands",level:2},{value:"Try With AI",id:"try-with-ai",level:2}];function d(n){const e={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"lesson-5-bringing-robots-to-life-with-ros-2-launch-and-control",children:"Lesson 5: Bringing Robots to Life with ROS 2 Launch and Control"})}),"\n",(0,t.jsxs)(e.p,{children:["In the exciting world of robotics, we need a way to orchestrate all the different components that make our robots move and think. This is where ROS 2 launch files and ",(0,t.jsx)(e.code,{children:"ros2_control"})," come into play. They are like the conductor of an orchestra, ensuring every instrument plays its part perfectly."]}),"\n",(0,t.jsx)(e.h2,{id:"the-magic-of-ros-2-launch-files",children:"The Magic of ROS 2 Launch Files"}),"\n",(0,t.jsx)(e.p,{children:"Imagine you have a complex robot with many sensors, actuators, and software nodes. Manually starting each component would be a nightmare! ROS 2 launch files solve this by allowing you to define and execute multiple ROS 2 nodes and other commands with a single command. Think of them as blueprints for your robot's software ecosystem."}),"\n",(0,t.jsx)(e.p,{children:"Launch files are especially crucial when you want to spawn your robot models into simulation environments like Gazebo. They tell Gazebo which URDF file to load, where to place the robot, and how to configure its controllers."}),"\n",(0,t.jsx)(e.h2,{id:"spawning-your-urdf-model-in-gazebo",children:"Spawning Your URDF Model in Gazebo"}),"\n",(0,t.jsx)(e.p,{children:"Let's create a simple ROS 2 launch file to bring our URDF model to life in Gazebo. This launch file will start Gazebo and then load our robot description."}),"\n",(0,t.jsxs)(e.p,{children:["First, create a new file named ",(0,t.jsx)(e.code,{children:"spawn_robot.launch.py"})," in your robot's ROS 2 package (e.g., ",(0,t.jsx)(e.code,{children:"my_robot_description/launch"}),")."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="launch/spawn_robot.launch.py"',children:"import os\r\nfrom ament_index_python.packages import get_package_share_directory\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch_ros.actions import Node\r\n\r\ndef generate_launch_description():\r\n    # Get the share directory for your robot package\r\n    pkg_share_dir = get_package_share_directory('my_robot_description')\r\n\r\n    # Path to your URDF file\r\n    urdf_path = os.path.join(pkg_share_dir, 'urdf', 'my_robot.urdf')\r\n\r\n    # Start Gazebo simulation\r\n    gazebo_launch = IncludeLaunchDescription(\r\n        PythonLaunchDescriptionSource([os.path.join(\r\n            get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']),\r\n        launch_arguments={'gui': 'true'}.items(),\r\n    )\r\n\r\n    # Spawn the robot into Gazebo\r\n    spawn_entity = Node(\r\n        package='gazebo_ros',\r\n        executable='spawn_entity.py',\r\n        arguments=['-file', urdf_path, '-entity', 'my_robot'],\r\n        output='screen'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        gazebo_launch,\r\n        spawn_entity\r\n    ])\n"})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"\ud83d\udcac AI Colearning Prompt"}),": Run this launch file! What happens when you execute ",(0,t.jsx)(e.code,{children:"ros2 launch my_robot_description spawn_robot.launch.py"}),"?"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Next, execute the launch file from your terminal:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"ros2 launch my_robot_description spawn_robot.launch.py\n"})}),"\n",(0,t.jsx)(e.p,{children:"Output:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"[INFO] [launch]: All requested procedures have been executed\r\n[gazebo_ros2_control-1] [INFO] [1678886400.123456789] [gazebo_ros2_control]: Loading ros2_control plugin\r\n[spawn_entity.py-2] [INFO] [1678886400.987654321] [spawn_entity]: Spawning entity with name 'my_robot'\r\n[spawn_entity.py-2] [INFO] [1678886401.000000000] [spawn_entity]: Entity 'my_robot' spawned successfully.\r\n... (Gazebo GUI should open with your robot)\n"})}),"\n",(0,t.jsx)(e.p,{children:"You should see Gazebo open with your robot model present in the simulation environment. This single command handles launching Gazebo and then injecting your robot."}),"\n",(0,t.jsxs)(e.h2,{id:"configuring-ros2_control-for-your-robot",children:["Configuring ",(0,t.jsx)(e.code,{children:"ros2_control"})," for Your Robot"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"ros2_control"})," is a powerful framework in ROS 2 that provides a standardized way to interface with robot hardware and simulate robot control. For our simulated robot, it allows us to send commands to its joints and read their states."]}),"\n",(0,t.jsxs)(e.p,{children:["To use ",(0,t.jsx)(e.code,{children:"ros2_control"}),", you need to:"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Install the necessary packages"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-gazebo-ros2-control\n"})}),"\n",(0,t.jsx)(e.p,{children:"Output:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Reading package lists... Done\r\nBuilding dependency tree... Done\r\nReading state information... Done\r\nros-humble-ros2-control is already the newest version (2.1.0-1jammy.20230303.234149).\r\nros-humble-ros2-controllers is already the newest version (2.1.0-1jammy.20230303.235500).\r\nros-humble-gazebo-ros2-control is already the newest version (0.6.0-1jammy.20230303.234150).\r\n0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.\n"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:["Add ",(0,t.jsx)(e.code,{children:"ros2_control"})," configuration to your URDF"]}),": You need to define the controllers you want to use in your URDF file. This involves adding ",(0,t.jsx)(e.code,{children:"ros2_control"})," tags that specify the robot's hardware interface."]}),"\n",(0,t.jsxs)(e.p,{children:["Here's an example of how to integrate ",(0,t.jsx)(e.code,{children:"ros2_control"})," into your ",(0,t.jsx)(e.code,{children:"my_robot.urdf"})," for a simple revolute joint:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",metastring:'title="urdf\\my_robot.urdf"',children:'<robot name="my_robot">\r\n    \x3c!-- ... existing links and joints ... --\x3e\r\n\r\n    <joint name="revolute_joint" type="revolute">\r\n        <parent link="base_link"/>\r\n        <child link="link_1"/>\r\n        <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n        <axis xyz="0 0 1"/>\r\n        <limit lower="-1.57" upper="1.57" effort="100" velocity="10"/>\r\n    </joint>\r\n\r\n    \x3c!-- ros2_control configuration --\x3e\r\n    <ros2_control name="RobotHardware" type="system">\r\n        <hardware>\r\n            <plugin>gazebo_ros2_control/GazeboSystem</plugin>\r\n        </hardware>\r\n        <joint name="revolute_joint">\r\n            <command_interface name="position">\r\n                <param name="min"> -1.57 </param>\r\n                <param name="max"> 1.57 </param>\r\n            </command_interface>\r\n            <state_interface name="position"/>\r\n            <state_interface name="velocity"/>\r\n        </joint>\r\n    </ros2_control>\r\n\r\n    <gazebo>\r\n        <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\r\n            <parameters>$(find my_robot_description)/config/my_robot_controllers.yaml</parameters>\r\n        </plugin>\r\n    </gazebo>\r\n\r\n</robot>\n'})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Create a controller configuration file"}),": This YAML file defines the specific controllers you want to load, such as joint position controllers. Create a file named ",(0,t.jsx)(e.code,{children:"my_robot_controllers.yaml"})," in a ",(0,t.jsx)(e.code,{children:"config"})," directory within your robot package."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",metastring:'title="config/my_robot_controllers.yaml"',children:"    controller_manager:\r\n      ros__parameters:\r\n        update_rate: 100 # Hz\r\n\r\n    joint_state_broadcaster:\r\n      ros__parameters:\r\n        type: joint_state_broadcaster/JointStateBroadcaster\r\n\r\n    revolute_joint_position_controller:\r\n      ros__parameters:\r\n        type: position_controllers/JointPositionController\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"4",children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Update your launch file to load controllers"}),": Modify ",(0,t.jsx)(e.code,{children:"spawn_robot.launch.py"})," to include the ",(0,t.jsx)(e.code,{children:"ros2_control"})," controller manager and load your defined controllers."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="launch\\spawn_robot.launch.py"',children:"import os\r\nfrom ament_index_python.packages import get_package_share_directory\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import IncludeLaunchDescription, DeclareLaunchArgument\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch.substitutions import LaunchConfiguration, Command\r\nfrom launch_ros.actions import Node\r\n\r\ndef generate_launch_description():\r\n    pkg_share_dir = get_package_share_directory('my_robot_description')\r\n    urdf_path = os.path.join(pkg_share_dir, 'urdf', 'my_robot.urdf')\r\n    controller_config_path = os.path.join(pkg_share_dir, 'config', 'my_robot_controllers.yaml')\r\n\r\n    robot_description = Command(['xacro ', urdf_path])\r\n\r\n    # Start Gazebo simulation\r\n    gazebo_launch = IncludeLaunchDescription(\r\n        PythonLaunchDescriptionSource([os.path.join(\r\n            get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']),\r\n        launch_arguments={'gui': 'true'}.items(),\r\n    )\r\n\r\n    # Spawn the robot into Gazebo\r\n    spawn_entity = Node(\r\n        package='gazebo_ros',\r\n        executable='spawn_entity.py',\r\n        arguments=['-file', urdf_path, '-entity', 'my_robot'],\r\n        output='screen'\r\n    )\r\n\r\n    # Robot State Publisher\r\n    robot_state_publisher_node = Node(\r\n        package='robot_state_publisher',\r\n        executable='robot_state_publisher',\r\n        parameters=[{'robot_description': robot_description}],\r\n        output='screen'\r\n    )\r\n\r\n    # ros2_control controller manager\r\n    control_node = Node(\r\n        package=\"controller_manager\",\r\n        executable=\"ros2_control_node\",\r\n        parameters=[robot_description, controller_config_path],\r\n        output=\"screen\",\r\n    )\r\n\r\n    # Load the joint state broadcaster\r\n    joint_state_broadcaster_spawner = Node(\r\n        package=\"controller_manager\",\r\n        executable=\"spawner\",\r\n        arguments=[\"joint_state_broadcaster\", \"--controller-manager\", \"/controller_manager\"],\r\n    )\r\n\r\n    # Load the joint position controller\r\n    joint_position_controller_spawner = Node(\r\n        package=\"controller_manager\",\r\n        executable=\"spawner\",\r\n        arguments=[\"revolute_joint_position_controller\", \"--controller-manager\", \"/controller_manager\"],\r\n    )\r\n\r\n    return LaunchDescription([\r\n        gazebo_launch,\r\n        spawn_entity,\r\n        robot_state_publisher_node,\r\n        control_node,\r\n        joint_state_broadcaster_spawner,\r\n        joint_position_controller_spawner\r\n    ])\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\r\n> **\ud83d\udcac AI Colearning Prompt**: After making these changes, relaunch your robot. Do you see any new topics published related to joint states?\r\n\r\nExecute the updated launch file from your terminal:\r\n\r\n```bash\r\nros2 launch my_robot_description spawn_robot.launch.py\n"})}),"\n",(0,t.jsx)(e.p,{children:"Output:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"[INFO] [launch]: All requested procedures have been executed\r\n[gazebo_ros2_control-1] [INFO] [1678886400.123456789] [gazebo_ros2_control]: Loading ros2_control plugin\r\n[spawn_entity.py-2] [INFO] [1678886400.987654321] [spawn_entity]: Spawning entity with name 'my_robot'\r\n[spawn_entity.py-2] [INFO] [1678886401.000000000] [spawn_entity]: Entity 'my_robot' spawned successfully.\r\n[controller_manager-3] [INFO] [1678886401.500000000] [controller_manager]: Loading controller 'joint_state_broadcaster'\r\n[spawner-4] [INFO] [1678886401.600000000] [joint_state_broadcaster]: Successfully loaded controller joint_state_broadcaster\r\n[controller_manager-3] [INFO] [1678886401.700000000] [controller_manager]: Loading controller 'revolute_joint_position_controller'\r\n[spawner-5] [INFO] [1678886401.800000000] [revolute_joint_position_controller]: Successfully loaded controller revolute_joint_position_controller\r\n... (Gazebo GUI should open with your robot, and controllers are active)\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Now, when you run the launch file, Gazebo will open, your robot will be spawned, and ",(0,t.jsx)(e.code,{children:"ros2_control"})," will be active, ready to receive commands."]}),"\n",(0,t.jsx)(e.h2,{id:"sending-joint-commands-with-a-ros-2-publisher",children:"Sending Joint Commands with a ROS 2 Publisher"}),"\n",(0,t.jsxs)(e.p,{children:["With ",(0,t.jsx)(e.code,{children:"ros2_control"})," configured, we can now send commands to our robot's joints. We'll create a simple ROS 2 publisher that sends position commands to our ",(0,t.jsx)(e.code,{children:"revolute_joint"}),"."]}),"\n",(0,t.jsxs)(e.p,{children:["Create a new Python script named ",(0,t.jsx)(e.code,{children:"joint_command_publisher.py"})," in your robot package's ",(0,t.jsx)(e.code,{children:"scripts"})," directory (e.g., ",(0,t.jsx)(e.code,{children:"my_robot_description/scripts"}),")."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="scripts\\joint_command_publisher.py"',children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float64\r\n\r\nclass JointCommandPublisher(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('joint_command_publisher')\r\n        self.publisher_ = self.create_publisher(Float64, '/revolute_joint_position_controller/commands', 10)\r\n        timer_period = 0.5  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n        self.position = 0.0\r\n        self.direction = 1\r\n\r\n    def timer_callback(self):\r\n        msg = Float64()\r\n        msg.data = self.position\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\r\n\r\n        self.position += 0.1 * self.direction\r\n        if self.position > 1.0 or self.position < -1.0:\r\n            self.direction *= -1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    joint_command_publisher = JointCommandPublisher()\r\n    rclpy.spin(joint_command_publisher)\r\n    joint_command_publisher.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(e.p,{children:"Make sure to make the script executable:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"chmod +x my_robot_description/scripts/joint_command_publisher.py\n"})}),"\n",(0,t.jsx)(e.p,{children:"On successful execution, this command typically produces no output."}),"\n",(0,t.jsx)(e.p,{children:"Now, run this publisher node in a new terminal (after launching your robot):"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"ros2 run my_robot_description joint_command_publisher.py\n"})}),"\n",(0,t.jsx)(e.p,{children:"Output:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'[INFO] [joint_command_publisher]: Publishing: "0.0"\r\n[INFO] [joint_command_publisher]: Publishing: "0.1"\r\n[INFO] [joint_command_publisher]: Publishing: "0.2"\r\n...\n'})}),"\n",(0,t.jsxs)(e.p,{children:["You should see the joint position commands being published to the ",(0,t.jsx)(e.code,{children:"/revolute_joint_position_controller/commands"})," topic."]}),"\n",(0,t.jsx)(e.h2,{id:"verifying-joint-commands",children:"Verifying Joint Commands"}),"\n",(0,t.jsxs)(e.p,{children:["It's essential to verify that our commands are actually reaching the robot and influencing its behavior in Gazebo. We can do this using ",(0,t.jsx)(e.code,{children:"ros2 topic echo"})," and by observing the robot's joint state in Gazebo."]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:["Using ",(0,t.jsx)(e.code,{children:"ros2 topic echo"})]}),": In a new terminal, while your robot is launched and the publisher is running, use ",(0,t.jsx)(e.code,{children:"ros2 topic echo"})," to listen to the joint state topic."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"ros2 topic echo /joint_states\n"})}),"\n",(0,t.jsx)(e.p,{children:"Output:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"header:\r\n  stamp:\r\n    sec: 1678886500\r\n    nanosec: 123456789\r\n  frame_id: ''\r\nname:\r\n- revolute_joint\r\nposition:\r\n- 0.19999999999999998\r\nvelocity:\r\n- 0.20000000000000001\r\neffort: []\r\n---\r\nheader:\r\n  stamp:\r\n    sec: 1678886500\r\n    nanosec: 623456789\r\n  frame_id: ''\r\nname:\r\n- revolute_joint\r\nposition:\r\n- 0.29999999999999999\r\nvelocity:\r\n- 0.19999999999999998\r\neffort: []\r\n---\r\n...\n"})}),"\n",(0,t.jsxs)(e.p,{children:["You should see the ",(0,t.jsx)(e.code,{children:"position"})," of the ",(0,t.jsx)(e.code,{children:"revolute_joint"})," changing, reflecting the commands sent by our publisher."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Observing in Gazebo"}),": In the Gazebo simulation, you should physically see your robot's ",(0,t.jsx)(e.code,{children:"revolute_joint"})," moving back and forth as the position commands are applied. This visual feedback confirms that the entire control pipeline is working correctly. You can also inspect the joint properties within Gazebo's interface to see its current position."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"try-with-ai",children:"Try With AI"}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"\ud83d\udcac AI Colearning Prompt"}),": Experiment with the ",(0,t.jsx)(e.code,{children:"joint_command_publisher.py"})," script."]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Change the ",(0,t.jsx)(e.code,{children:"timer_period"})," to make the joint move faster or slower."]}),"\n",(0,t.jsxs)(e.li,{children:["Modify the ",(0,t.jsx)(e.code,{children:"position"})," update logic to make the joint move to a specific target position and hold, instead of oscillating."]}),"\n",(0,t.jsx)(e.li,{children:"How would you add another joint to your URDF and control it independently?"}),"\n"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);